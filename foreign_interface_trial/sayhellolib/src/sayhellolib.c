// ---
// sayhellolib.c
// ---

#include <SWI-Prolog.h>
#include <stdio.h>
#include <assert.h>
#include <stdbool.h>
#include <string.h>

// numeric ids for the "encoding"
//
// All of these values can be distingusihed from FALSE (and also from TRUE)
// so a function can return either these or FALSE.

/*
 * This works in CLion but not in gcc. But CLion uses gcc, too. What gives?
static const int iso_latin_1 = 10;
static const int utf8        = 20;
static const int multibyte   = 30;
*/

#define iso_latin_1 10
#define utf8        20
#define multibyte   30

static char*
enc_id__to__string(int enc_id) {
    switch (enc_id) {
        case iso_latin_1: return "iso_latin_1";
        case utf8: return "utf8";
        case multibyte: return "multibyte";
        default: assert(false);
    }
}

// As described at https://eu.swi-prolog.org/pldoc/man?section=foreign-term-analysis
// these are the or-able values to set the encoding to be used when pulling out
// text from an atom or string into an array of bytes (i.e. into a char*)

static int
enc_id__to__get_chars_flag(int enc_id) {
    switch (enc_id) {
        case iso_latin_1: return REP_ISO_LATIN_1;
        case utf8: return REP_UTF8;
        case multibyte: return REP_MB;
        default: assert(false);
    }
}

// Find out whether the atom (or string) "enc" contains one of the texts "iso_latin_1", "utf8",
// "multibyte" and return a numeric id as replacement. May return FALSE instead, which is
// distinguishable from a valid numeric id.

static int
enc_term__to__enc_id(term_t enc_term) {
    int tt = PL_term_type(enc_term);
    if (tt != PL_ATOM) {
        return FALSE;
    }
    char *s; // will contain the text in "enc" encoded in UTF-8
    {
        int res2 = PL_get_chars(enc_term, &s, CVT_ATOM | CVT_STRING | BUF_MALLOC | REP_UTF8);
        if (!res2) {
            return FALSE; // conversion failure, so not one of the ASCII-only texts
        }
    }
    int res = FALSE; // default is failure
    // using strmcp() to compare the literal "utf8" and the content of "char* s"
    // (probably) works because the literal "utf8" is (probably) encoded to UTF8 by the compiler
    if (0 == strcmp("utf8", s)) {
        res = utf8;
    }
    else if (0 == strcmp("iso_latin_1", s)) {
        res = iso_latin_1;
    }
    else if (0 == strcmp("multibyte", s)) {
        res = multibyte;
    }
    PL_free(s); // free s because we demanded it be malloc'd via BUF_MALLOC flag
    return res;
}

// Actually extracing text from a term and saying "Hello, $text" to STDOUT.
// The return value is the one generated by PL_get_chars (i.e. TRUE or FALSE)
// so it can be returned "upwards" by the caller as well.

static int
extract_text_and_say(term_t enc_term, int enc_id) {
    int enc_flag = enc_id__to__get_chars_flag(enc_id);
    char *s;
    if (PL_get_chars(enc_term, &s, CVT_ATOM|CVT_STRING|BUF_MALLOC|enc_flag)) {
        // The bytes in "cahr *s" representing a successfully converted string are now
        // written to the terminal, which may or may not properly work depending on
        // the setting of the LANG environment variable for example
        printf("Hello, %s\n", s);
        PL_free(s);
        PL_succeed;
    }
    else {
        fprintf(stderr, "extract_text_and_say() says: Extraction of text from term failed with target encoding '%s'\n", enc_id__to__string(enc_id));
        PL_fail;
    }
}

// If "t" happens to be a "reference to an atom or string", get the text out of the atom or string
// into a sequence of bytes (char *s). The bytes encode the text according to the target encoding
// "enc" (itself an atom or string): 'iso_latin_1', 'utf8', 'multibyte'.
//
// We do not consider "wide characters" functions.
//
// Functions used:
// PL_get_atom_chars: https://eu.swi-prolog.org/pldoc/doc_for?object=c(%27PL_get_atom_chars%27)

static foreign_t
pl_say_hello(term_t t, term_t enc_term) {
    int enc_id = enc_term__to__enc_id(enc_term);
    if (enc_id == FALSE) {
        fprintf(stderr, "pl_say_hello() says: Failure interpreting 'enc_term'\n");
        PL_fail; // return at once
    }
    fprintf(stderr, "pl_say_hello() says: 'enc_term' yields 'enc_id' %d (%s)\n", enc_id, enc_id__to__string(enc_id));
    return extract_text_and_say(t, enc_id);
}

// The function which registers the function of interest, namely "pl_say_hello()", as
// predicate "say_hello/2". It is run by the Prolog Processor when the shared library
// is loaded. The library and the function name must match: "sayhellolib".
//
// https://eu.swi-prolog.org/pldoc/doc_for?object=c(%27PL_register_foreign_in_module%27)
// https://eu.swi-prolog.org/pldoc/man?section=foreignlink

install_t
install_sayhellolib() {
    int res = PL_register_foreign("say_hello", 2, pl_say_hello, 0);
    if (!res) {
        fprintf(stderr, "install_sayhellolib() says: Failure registering 'say_hello/2'\n");
    }
    else {
        fprintf(stderr, "install_sayhellolib() says: Successfully registered 'say_hello/2'\n");
    }
}
